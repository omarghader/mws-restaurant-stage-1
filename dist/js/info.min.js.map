{"version":3,"sources":["shared.js","dbhelper.js","connectivity.js","restaurant_info.js","swregister.js"],"names":["responsiveBreakPoints","media","minwidth","maxwidth","imgSuffix","imgCondition","sizes","srcset","responsiveImage","figure","document","restaurant","picture","breakPoint","createElement","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","Symbol","iterator","next","done","source","value","className","srcsets","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","push","DBHelper","imageUrlForRestaurant","err","return","length","join","append","image","src","alt","name","figureCaption","innerHTML","lazy","querySelectorAll","console","log","lazyLoad","i","isInViewport","getAttribute","removeAttribute","cleanLazy","Array","prototype","filter","call","l","el","rect","top","window","innerHeight","documentElement","clientHeight","innerWidth","clientWidth","event","func","addEventListener","setLazy","attachEvent","registerListener","restoDbname","reviewsDbname","objectStore","pendingReviewsID","open","indexedDB","onupgradeneeded","result","createObjectStore","keyPath","data","initDB","onsuccess","transaction","resto","store","put","query","db","tx","res","getAll","get","parseInt","callback","oncomplete","close","getRestoFromDB","fetch","DATABASE_URL","then","json","restaurants","storeRestoToDB","id","fetchRestaurants","error","find","r","cuisine","cuisine_type","results","neighborhood","neighborhoods","map","v","uniqueNeighborhoods","indexOf","cuisines","uniqueCuisines","dimension","google","maps","Marker","position","latlng","title","url","urlForRestaurant","animation","Animation","DROP","createIndex","initReviewsDB","forEach","index","marker","getReviewsFromDB","pendingReviews","getPendingReviewsByID","restoReviews","concat","reviews","slice","storeReviewsToDB","catch","review","JSON","parse","localStorage","getItem","existingEntries","setItem","stringify","getPendingReviews","numericID","pendingReview","restaurant_id","removeItem","method","headers","body","ClearPendingReview","handleModalReviews","modal","btn","getElementById","span","getElementsByClassName","onclick","style","display","target","fetchRestaurantFromURL","self","fillBreadcrumb","initMap","Map","center","getParameterByName","fillRestaurantHTML","fillReviewsHTML","arguments","address","container","operating_hours","fillRestaurantHoursHTML","operatingHours","hours","firstChild","removeChild","key","day","time","row","appendChild","querySelector","noReviews","ul","fillReviewsList","createReviewHTML","date","Date","createdAt","toDateString","li","rating","comments","currentPage","setAttribute","location","href","breadcrumb","exec","replace","sendReview","form","decodeURIComponent","elements","Accept","addPendingReview","finally","SWService","navigator","serviceWorker","indexController","this","register","reg","controller","waiting","updateReady","trackInstalling","installing","refreshing","reload","_dbPromise","_postsView","showingPosts","indexedDBName","messages","addPosts","reverse","worker","state","postMessage","action","swregister","registerServiceWorker"],"mappings":"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","file":"info.min.js","sourcesContent":["\n\nconst responsiveBreakPoints = [\n  {\n    media: {\n      minwidth: 0,\n      maxwidth: 500,\n    },\n    srcset: [\n      {\n        imgSuffix: 'small',\n        imgCondition: '450w',\n      },\n    ],\n    sizes: [],\n  }, {\n    media: {\n      minwidth: 501,\n      maxwidth: 850,\n    },\n    srcset: [\n      {\n        imgSuffix: 'medium',\n        imgCondition: '550w',\n      },\n    ],\n    sizes: [],\n  }, {\n    media: {\n      minwidth: 851,\n      maxwidth: null,\n    },\n    srcset: [\n      {\n        imgSuffix: 'large',\n        imgCondition: '800w',\n      },\n    ],\n    sizes: [],\n  },\n];\n\nconst responsiveImage = (restaurant) => {\n  const figure = document.createElement('figure');\n  const picture = document.createElement('picture');\n\n  for (const breakPoint of responsiveBreakPoints) {\n    const source = document.createElement('source');\n    source.className = 'lazy';\n\n    source.media = '';\n    if (breakPoint.media.maxwidth && breakPoint.media.minwidth) {\n      source.media += `(min-width: ${breakPoint.media.minwidth}px) and (max-width: ${breakPoint.media.maxwidth}px)`;\n    } else {\n      if (breakPoint.media.minwidth) { source.media += `(min-width: ${breakPoint.media.minwidth}px)`; }\n      if (breakPoint.media.maxwidth) { source.media += `(max-width: ${breakPoint.media.maxwidth}px)`; }\n    }\n\n    const srcsets = [];\n\n    for (const srcset of breakPoint.srcset) {\n      if (srcset.imgSuffix === 'small') { continue; }\n      srcsets.push(`${DBHelper.imageUrlForRestaurant(restaurant, srcset.imgSuffix)}  ${srcset.imgCondition}`);\n    }\n\n    // if there is src set Add\n    if (srcsets.length > 0) {\n      source.srcset = srcsets.join(srcsets, ',');\n      // source.dataset.srcset = srcsets.join(srcsets, ',');\n\n      picture.append(source);\n    }\n  }\n\n  const image = document.createElement('img');\n  image.className = 'restaurant-img';\n  image.src = DBHelper.imageUrlForRestaurant(restaurant, 'small');\n  // image.dataset.src = DBHelper.imageUrlForRestaurant(restaurant, 'small');\n  image.alt = `Image of the restaurant ${restaurant.name}`;\n  picture.append(image);\n\n  figure.append(picture);\n\n  const figureCaption = document.createElement('figcaption');\n  figureCaption.innerHTML = restaurant.name;\n  figure.append(figureCaption);\n\n  return figure;\n};\n\n//\nlet lazy = [];\n\n\nfunction setLazy() {\n  // document.getElementById('listing').removeChild(document.getElementById('viewMore'));\n  // document.getElementById('nextPage').removeAttribute('class');\n\n  lazy = document.querySelectorAll('img[data-src]');\n  console.log(`Found ${lazy.length} lazy images`);\n}\n\nfunction lazyLoad() {\n  lazy = document.querySelectorAll('img[data-src]');\n\n  for (let i = 0; i < lazy.length; i++) {\n    if (isInViewport(lazy[i])) {\n      if (lazy[i].getAttribute('data-src')) {\n        lazy[i].src = lazy[i].getAttribute('data-src');\n        lazy[i].removeAttribute('data-src');\n      }\n    }\n  }\n\n  cleanLazy();\n}\n\nfunction cleanLazy() {\n  lazy = Array.prototype.filter.call(lazy, l => l.getAttribute('data-src'));\n}\n\nfunction isInViewport(el) {\n  const rect = el.getBoundingClientRect();\n\n  return (\n    rect.bottom >= 0 &&\n        rect.right >= 0 &&\n        rect.top <= (window.innerHeight || document.documentElement.clientHeight) &&\n        rect.left <= (window.innerWidth || document.documentElement.clientWidth)\n  );\n}\n\nfunction registerListener(event, func) {\n  if (window.addEventListener) {\n    window.addEventListener(event, func);\n  } else {\n    window.attachEvent(`on${event}`, func);\n  }\n}\n\n\nregisterListener('load', setLazy);\nregisterListener('load', lazyLoad);\nregisterListener('scroll', lazyLoad);\nregisterListener('resize', lazyLoad);\n","/**\n * Common database helper functions.\n */\n\nconst restoDbname = 'restomws';\nconst reviewsDbname = 'reviewsmws';\nconst objectStore = 'mwsObjectStore';\nconst pendingReviewsID = 'pendingReviews';\n\n// eslint-disable-next-line\nclass DBHelper {\n  /**\n   * Database URL.\n   * Change this to restaurants.json file location on your server.\n   */\n  static get DATABASE_URL() {\n    const port = 1337; // Change this to your server port\n    return `http://localhost:${port}`;\n  }\n\n  // ===========================================\n  // Restaurants\n  // ===========================================\n\n  static initDB() {\n    // This works on all devices/browsers, and uses IndexedDBShim as a final fallback\n    const indexedDB = window.indexedDB; // eslint-disable-line\n\n    // Open (or create) the database\n    const open = indexedDB.open(restoDbname, 1);\n\n    // Create the schema\n    open.onupgradeneeded = function onupgradeneeded() {\n      const db = open.result;\n      db.createObjectStore(objectStore, { keyPath: 'id' });\n      // var index = store.createIndex(\"NameIndex\", [\"name.last\", \"name.first\"]);\n    };\n\n    return open;\n  }\n\n\n  static storeRestoToDB(data) {\n    const open = DBHelper.initDB();\n\n    open.onsuccess = function onsuccess() {\n      // Start a new transaction\n      const db = open.result;\n      const tx = db.transaction(objectStore, 'readwrite');\n      const store = tx.objectStore(objectStore);\n\n      data.forEach((resto) => {\n        store.put(resto);\n      });\n    };\n  }\n\n  static getRestoFromDB(query, callback) {\n    const open = DBHelper.initDB();\n\n    open.onsuccess = function onsuccess() {\n      // Start a new transaction\n      const db = open.result;\n      const tx = db.transaction(objectStore, 'readwrite');\n      const store = tx.objectStore(objectStore);\n\n      let res = store.getAll();\n      if (query) {\n        res = store.get(parseInt(query, 10));\n      }\n\n      res.onsuccess = function resonsuccess() {\n        callback(res.result);\n      };\n\n      // Close the db when the transaction is done\n      tx.oncomplete = function oncomplete() {\n        db.close();\n      };\n    };\n  }\n\n\n  // ===========================================\n  // ===========================================\n\n  /**\n   * Fetch all restaurants.\n   */\n  static fetchRestaurants(callback) {\n    DBHelper.getRestoFromDB(null, (data) => {\n      if (data) {\n        callback(null, data);\n      }\n\n      // eslint-disable-next-line\n      fetch(`${DBHelper.DATABASE_URL}/restaurants`).then(res => res.json()).then((restaurants) => {\n        callback(null, restaurants);\n        DBHelper.storeRestoToDB(restaurants);\n      }).catch((err) => {\n        const error = ('Request failed', err);\n        callback(error, null);\n      });\n    });\n  }\n\n\n  /**\n   * Fetch a restaurant by its ID.\n   */\n  static fetchRestaurantById(id, callback) {\n    // fetch all restaurants with proper error handling.\n    DBHelper.getRestoFromDB(id, (data) => {\n      if (data) {\n        callback(null, data);\n        return;\n      }\n\n      DBHelper.fetchRestaurants((error, restaurants) => {\n        if (error) {\n          callback(error, null);\n        } else {\n          const restaurant = restaurants.find(r => r.id === id);\n          if (restaurant) { // Got the restaurant\n            callback(null, restaurant);\n          } else { // Restaurant does not exist in the database\n            callback('Restaurant does not exist', null);\n          }\n        }\n      });\n    });\n  }\n\n  /**\n   * Fetch restaurants by a cuisine type with proper error handling.\n   */\n  static fetchRestaurantByCuisine(cuisine, callback) {\n    // Fetch all restaurants  with proper error handling\n    DBHelper.fetchRestaurants((error, restaurants) => {\n      if (error) {\n        callback(error, null);\n      } else {\n        // Filter restaurants to have only given cuisine type\n        const results = restaurants.filter(r => r.cuisine_type === cuisine);\n        callback(null, results);\n      }\n    });\n  }\n\n  /**\n   * Fetch restaurants by a neighborhood with proper error handling.\n   */\n  static fetchRestaurantByNeighborhood(neighborhood, callback) {\n    // Fetch all restaurants\n    DBHelper.fetchRestaurants((error, restaurants) => {\n      if (error) {\n        callback(error, null);\n      } else {\n        // Filter restaurants to have only given neighborhood\n        const results = restaurants.filter(r => r.neighborhood === neighborhood);\n        callback(null, results);\n      }\n    });\n  }\n\n  /**\n   * Fetch restaurants by a cuisine and a neighborhood with proper error handling.\n   */\n  static fetchRestaurantByCuisineAndNeighborhood(cuisine, neighborhood, callback) {\n    // Fetch all restaurants\n    DBHelper.fetchRestaurants((error, restaurants) => {\n      if (error) {\n        callback(error, null);\n      } else {\n        let results = restaurants;\n        if (cuisine !== 'all') { // filter by cuisine\n          results = results.filter(r => r.cuisine_type === cuisine);\n        }\n        if (neighborhood !== 'all') { // filter by neighborhood\n          results = results.filter(r => r.neighborhood === neighborhood);\n        }\n        callback(null, results);\n      }\n    });\n  }\n\n  /**\n   * Fetch all neighborhoods with proper error handling.\n   */\n  static fetchNeighborhoods(callback) {\n    // Fetch all restaurants\n    DBHelper.fetchRestaurants((error, restaurants) => {\n      if (error) {\n        callback(error, null);\n      } else {\n        // Get all neighborhoods from all restaurants\n        const neighborhoods = restaurants.map((v, i) => restaurants[i].neighborhood);\n        // Remove duplicates from neighborhoods\n        const uniqueNeighborhoods = neighborhoods.filter((v, i) => neighborhoods.indexOf(v) === i);\n        callback(null, uniqueNeighborhoods);\n      }\n    });\n  }\n\n  /**\n   * Fetch all cuisines with proper error handling.\n   */\n  static fetchCuisines(callback) {\n    // Fetch all restaurants\n    DBHelper.fetchRestaurants((error, restaurants) => {\n      if (error) {\n        callback(error, null);\n      } else {\n        // Get all cuisines from all restaurants\n        const cuisines = restaurants.map((v, i) => restaurants[i].cuisine_type);\n        // Remove duplicates from cuisines\n        const uniqueCuisines = cuisines.filter((v, i) => cuisines.indexOf(v) === i);\n        callback(null, uniqueCuisines);\n      }\n    });\n  }\n\n  /**\n   * Restaurant page URL.\n   */\n  static urlForRestaurant(restaurant) {\n    return (`./restaurant.html?id=${restaurant.id}`);\n  }\n\n  /**\n   * Restaurant image URL.\n   */\n  static imageUrlForRestaurant(restaurant, dimension) {\n    switch (dimension) {\n      case 'large':\n        return (`/img/${restaurant.id}-large.jpg`);\n      case 'medium':\n        return (`/img/${restaurant.id}-medium.jpg`);\n      default:\n        return (`/img/${restaurant.id}-small.jpg`);\n    }\n  }\n\n  /**\n   * Map marker for a restaurant.\n   */\n  static mapMarkerForRestaurant(restaurant, map) {\n    // eslint-disable-next-line\n    if (!window.google) { return; }\n\n    // eslint-disable-next-line\n    const marker = new google.maps.Marker({\n      position: restaurant.latlng,\n      title: restaurant.name,\n      url: DBHelper.urlForRestaurant(restaurant),\n      map,\n      animation: google.maps.Animation.DROP,//eslint-disable-line\n    });\n    // eslint-disable-next-line\n    return marker;\n  }\n\n\n  // ===========================================\n  // Reviews\n  // ===========================================\n\n  static initReviewsDB() {\n  // This works on all devices/browsers, and uses IndexedDBShim as a final fallback\n    const indexedDB = window.indexedDB; // eslint-disable-line\n\n    // Open (or create) the database\n    const open = indexedDB.open(reviewsDbname, 1);\n\n    // Create the schema\n    open.onupgradeneeded = function onupgradeneeded() {\n      const db = open.result;\n      const store = db.createObjectStore(objectStore, { keyPath: 'id' });\n      store.createIndex('RestaurantIDIndex', ['restaurant_id']);\n    };\n\n    return open;\n  }\n\n\n  static storeReviewsToDB(data) {\n    const open = DBHelper.initReviewsDB();\n\n    open.onsuccess = function onsuccess() {\n    // Start a new transaction\n      const db = open.result;\n      const tx = db.transaction(objectStore, 'readwrite');\n      const store = tx.objectStore(objectStore);\n\n      data.forEach((resto) => {\n        store.put(resto);\n      });\n    };\n  }\n\n  static getReviewsFromDB(query, callback) {\n    const open = DBHelper.initReviewsDB();\n\n    open.onsuccess = function onsuccess() {\n    // Start a new transaction\n      const db = open.result;\n      const tx = db.transaction(objectStore, 'readwrite');\n      const store = tx.objectStore(objectStore);\n      const index = store.index('RestaurantIDIndex');\n\n      let res;\n      if (query) {\n        res = index.getAll([parseInt(query, 10)]);\n      } else {\n        res = index.getAll();\n      }\n\n      res.onsuccess = function resonsuccess() {\n        callback(res.result);\n      };\n\n      // Close the db when the transaction is done\n      tx.oncomplete = function oncomplete() {\n        db.close();\n      };\n    };\n  }\n\n  /**\n   * Fetch all restaurants.\n   */\n  static fetchReviewsByRestaurantID(id, callback) {\n    DBHelper.getReviewsFromDB(id, (data) => {\n      if (data) {\n        let restoReviews = data.slice(0);\n        const pendingReviews = DBHelper.getPendingReviewsByID(id);\n        restoReviews = restoReviews.concat(pendingReviews);\n        callback(null, restoReviews);\n      }\n\n      // eslint-disable-next-line\n      fetch(`${DBHelper.DATABASE_URL}/reviews?restaurant_id=${id}`).then(res => res.json()).then((reviews) => {\n        let restoReviews = reviews.slice(0);\n        const pendingReviews = DBHelper.getPendingReviewsByID(id);\n        restoReviews = restoReviews.concat(pendingReviews);\n\n        callback(null, restoReviews);\n        DBHelper.storeReviewsToDB(reviews);\n      }).catch((err) => {\n        const error = ('Request failed', err);\n        callback(error, null);\n      });\n    });\n  }\n\n  static addPendingReview(review) {\n    // Parse any JSON previously stored in allEntries\n    let existingEntries = JSON.parse(localStorage.getItem(pendingReviewsID));\n    if (existingEntries == null) existingEntries = [];\n    existingEntries.push(review);\n    localStorage.setItem(pendingReviewsID, JSON.stringify(existingEntries));\n  }\n\n  static getPendingReviews() {\n    // Parse any JSON previously stored in allEntries\n    let existingEntries = JSON.parse(localStorage.getItem(pendingReviewsID));\n    if (existingEntries == null) {\n      existingEntries = [];\n    }\n    return existingEntries;\n  }\n\n  static getPendingReviewsByID(id) {\n    const pendingReviews = DBHelper.getPendingReviews();\n    const numericID = parseInt(id, 10);\n\n    const restoReviews = [];\n\n    pendingReviews.forEach((pendingReview) => {\n      if (pendingReview.restaurant_id === numericID) {\n        restoReviews.push(pendingReview);\n      }\n    });\n    return restoReviews;\n  }\n\n  static ClearPendingReview() {\n    // Parse any JSON previously stored in allEntries\n    localStorage.removeItem(pendingReviewsID);\n  }\n}\n","window.addEventListener('online', () => {\n  // alert('Your connection is back');\n  const pendingReviews = DBHelper.getPendingReviews();\n  pendingReviews.forEach((pendingReview) => {\n    fetch('http://localhost:1337/reviews/', {\n      method: 'POST',\n      headers: {\n        Accept: 'application/json',\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(pendingReview),\n    }).then(res => res.json())\n      .catch((err) => {\n        console.log('[errorBeforeJSON]', err);\n      });\n  });\n\n  DBHelper.ClearPendingReview();\n});\nwindow.addEventListener('offline', () => {\n  alert('Connection lost! Please check your connection.');\n});\n","let restaurant;\nlet map;\n\n\ndocument.addEventListener('DOMContentLoaded', (event) => {\n  fetchRestaurantFromURL((error, restaurant) => {\n    if (error) { // Got an error!\n      console.error(error);\n    } else {\n      console.log('[DOMContentLoaded]', self.restaurant);\n      fillBreadcrumb();\n    }\n  });\n});\n\n/**\n * Initialize Google map, called from HTML.\n */\nwindow.initMap = () => {\n  fetchRestaurantFromURL((error, restaurant) => {\n    if (error) { // Got an error!\n      console.error(error);\n    } else {\n      self.map = new google.maps.Map(document.getElementById('map'), {\n        zoom: 16,\n        center: restaurant.latlng,\n        scrollwheel: false,\n      });\n      DBHelper.mapMarkerForRestaurant(self.restaurant, self.map);\n    }\n  });\n};\n\n\nfunction handleModalReviews() {\n  // Get the modal\n  const modal = document.getElementById('review-modal');\n\n  // Get the button that opens the modal\n  const btn = document.getElementById('open-review');\n\n  // Get the <span> element that closes the modal\n  const span = document.getElementsByClassName('close')[0];\n\n  // When the user clicks the button, open the modal\n  btn.onclick = function () {\n    modal.style.display = 'block';\n  };\n\n  // When the user clicks on <span> (x), close the modal\n  span.onclick = function () {\n    modal.style.display = 'none';\n  };\n\n  // When the user clicks anywhere outside of the modal, close it\n  window.onclick = function (event) {\n    if (event.target == modal) {\n      modal.style.display = 'none';\n    }\n  };\n}\n\nhandleModalReviews();\n\n/**\n * Get current restaurant from page URL.\n */\nconst fetchRestaurantFromURL = (callback) => {\n  if (self.restaurant) { // restaurant already fetched!\n    callback(null, self.restaurant);\n    return;\n  }\n  const id = getParameterByName('id');\n  if (!id) { // no id found in URL\n    console.log('[[IDNOTFOUND]]', id);\n    const error = 'No restaurant id in URL';\n    callback(error, null);\n  } else {\n    DBHelper.fetchRestaurantById(id, (error, restaurant) => {\n      self.restaurant = restaurant;\n      if (!restaurant) {\n        console.error(error);\n        return;\n      }\n      fillRestaurantHTML();\n      callback(null, restaurant);\n    });\n\n    DBHelper.fetchReviewsByRestaurantID(id, (error, reviews) => {\n      console.log('reviews', id, reviews, error);\n      if (!reviews) {\n        console.error(error);\n        return;\n      }\n      restaurant.reviews = reviews;\n      // fill reviews\n      fillReviewsHTML(restaurant.reviews);\n    });\n  }\n};\n\n/**\n * Create restaurant HTML and add it to the webpage\n */\nconst fillRestaurantHTML = (restaurant = self.restaurant) => {\n  const name = document.getElementById('restaurant-name');\n  name.innerHTML = restaurant.name;\n\n  const address = document.getElementById('restaurant-address');\n  address.innerHTML = restaurant.address;\n\n  // const image = document.getElementById('restaurant-img');\n  // image.className = 'restaurant-img'\n  // image.src = DBHelper.imageUrlForRestaurant(restaurant);\n\n  const image = responsiveImage(restaurant);\n  const container = document.getElementById('restaurant-container');\n  const figure = document.getElementById('restaurant-img');\n  figure.innerHTML = image.innerHTML;\n  // container.insertBefore(image, container.children[1])\n\n  const cuisine = document.getElementById('restaurant-cuisine');\n  cuisine.innerHTML = restaurant.cuisine_type;\n\n  // fill operating hours\n  if (restaurant.operating_hours) {\n    fillRestaurantHoursHTML();\n  }\n};\n\n/**\n * Create restaurant operating hours HTML table and add it to the webpage.\n */\nconst fillRestaurantHoursHTML = (operatingHours = self.restaurant.operating_hours) => {\n  const hours = document.getElementById('restaurant-hours');\n\n  // reset REVIEWS\n  while (hours.firstChild) {\n    hours.removeChild(hours.firstChild);\n  }\n\n  for (const key in operatingHours) {\n    const row = document.createElement('tr');\n\n    const day = document.createElement('td');\n    day.innerHTML = key;\n    row.appendChild(day);\n\n    const time = document.createElement('td');\n    time.innerHTML = operatingHours[key];\n    row.appendChild(time);\n\n    hours.appendChild(row);\n  }\n};\n\n/**\n * Create all reviews HTML and add them to the webpage.\n */\nconst fillReviewsHTML = (reviews = self.restaurant.reviews) => {\n  const container = document.getElementById('reviews-container');\n\n  if (!container.querySelector('h3')) {\n    const title = document.createElement('h3');\n    title.innerHTML = 'Reviews';\n    container.appendChild(title);\n  }\n\n\n  if (!reviews) {\n    const noReviews = document.createElement('p');\n    noReviews.innerHTML = 'No reviews yet!';\n    container.appendChild(noReviews);\n  }\n\n  fillReviewsList(reviews);\n};\n\nfunction fillReviewsList(reviews) {\n  const container = document.getElementById('reviews-container');\n  const ul = document.getElementById('reviews-list');\n\n  // reset REVIEWS\n  while (ul.firstChild) {\n    ul.removeChild(ul.firstChild);\n  }\n\n  reviews.forEach((review) => {\n    ul.appendChild(createReviewHTML(review));\n  });\n  container.appendChild(ul);\n}\n/**\n * Create review HTML and add it to the webpage.\n */\nconst createReviewHTML = (review) => {\n  const li = document.createElement('li');\n  const name = document.createElement('p');\n  name.innerHTML = review.name;\n  li.appendChild(name);\n\n  const date = document.createElement('p');\n  date.innerHTML = new Date(review.createdAt).toDateString();\n  li.appendChild(date);\n\n  const rating = document.createElement('p');\n  rating.innerHTML = `Rating: ${review.rating}`;\n  li.appendChild(rating);\n\n  const comments = document.createElement('p');\n  comments.innerHTML = review.comments;\n  li.appendChild(comments);\n\n  return li;\n};\n\n/**\n * Add restaurant name to the breadcrumb navigation menu\n */\nconst fillBreadcrumb = (restaurant = self.restaurant) => {\n  const breadcrumb = document.querySelector('#navBreadcrumb ul');\n  const li = document.createElement('li');\n  const currentPage = document.createElement('a');\n  currentPage.innerHTML = restaurant.name;\n  currentPage.setAttribute('href', location.href);\n  currentPage.setAttribute('aria-current', 'page');\n  li.appendChild(currentPage);\n  breadcrumb.appendChild(li);\n};\n\n/**\n * Get a parameter by name from page URL.\n */\nconst getParameterByName = (name, url) => {\n  if (!url) {\n    url = window.location.href;\n  }\n  name = name.replace(/[\\[\\]]/g, '\\\\$&');\n  const regex = new RegExp(`[?&]${name}(=([^&#]*)|&|#|$)`),\n    results = regex.exec(url);\n  if (!results) {\n    return null;\n  }\n  if (!results[2]) {\n    return '';\n  }\n  return decodeURIComponent(results[2].replace(/\\+/g, ' '));\n};\n\n/**\n * Send Review\n */\n\nconst sendReview = () => {\n  const modal = document.getElementById('review-modal');\n  const form = document.querySelector('#review-form');\n  const id = parseInt(getParameterByName('id'), 10);\n  const name = form.elements[0].value;\n  const rating = form.elements[1].value;\n  const comments = form.elements[2].value;\n\n  if (!id || !name || !rating || !comments) {\n    console.log('one value is missing');\n    return;\n  }\n\n  const body = {\n    createdAt: new Date().getTime(),\n    restaurant_id: id,\n    name,\n    rating,\n    comments,\n  };\n  fetch('http://localhost:1337/reviews/', {\n    method: 'POST',\n    headers: {\n      Accept: 'application/json',\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify(body),\n  }).then(res => res.json())\n    .catch((err) => {\n      console.log('[errorBeforeJSON]', err);\n      DBHelper.addPendingReview(body);\n    })\n    .finally(() => {\n      // Get the modal\n      form.reset();\n      modal.style.display = 'none';\n      console.log(id);\n      DBHelper.fetchReviewsByRestaurantID(id, (error, reviews) => {\n        console.log('reviews', reviews);\n        if (!reviews) {\n          console.error(error);\n          return;\n        }\n        restaurant.reviews = reviews;\n\n        // fill reviews\n        fillReviewsList(restaurant.reviews);\n      });\n    });\n};\n","class SWService {\n  registerServiceWorker() {\n    if (!navigator.serviceWorker) return;\n\n    const indexController = this;\n\n    navigator.serviceWorker.register('/sw.js').then((reg) => {\n      if (!navigator.serviceWorker.controller) {\n        return;\n      }\n\n      if (reg.waiting) {\n        indexController.updateReady(reg.waiting);\n        return;\n      }\n\n      if (reg.installing) {\n        indexController.trackInstalling(reg.installing);\n        return;\n      }\n\n      reg.addEventListener('updatefound', () => {\n        indexController.trackInstalling(reg.installing);\n      });\n    });\n\n    // Ensure refresh is only called once.\n    // This works around a bug in \"force update on reload\".\n    let refreshing;\n    navigator.serviceWorker.addEventListener('controllerchange', () => {\n      if (refreshing) return;\n      window.location.reload();\n      refreshing = true;\n    });\n  }\n\n  showCachedMessages() {\n    const indexController = this;\n\n    return this._dbPromise.then((db) => {\n      // if we're already showing posts, eg shift-refresh\n      // or the very first load, there's no point fetching\n      // posts from IDB\n      if (!db || indexController._postsView.showingPosts()) return;\n\n      const index = db.transaction(indexedDBName)\n        .objectStore(indexedDBName).index('by-date');\n\n      return index.getAll().then((messages) => {\n        indexController._postsView.addPosts(messages.reverse());\n      });\n    });\n  }\n\n  trackInstalling(worker) {\n    const indexController = this;\n    worker.addEventListener('statechange', () => {\n      if (worker.state == 'installed') {\n        indexController.updateReady(worker);\n      }\n    });\n  }\n\n\n  updateReady(worker) {\n    worker.postMessage({\n      action: 'skipWaiting',\n    });\n  }\n}\n\n\nconst swregister = new SWService();\nswregister.registerServiceWorker();\n"]}
{"version":3,"sources":["shared.js","dbhelper.js","connectivity.js","restaurant_info.js","swregister.js"],"names":["responsiveBreakPoints","media","minwidth","maxwidth","imgSuffix","imgCondition","sizes","srcset","responsiveImage","figure","document","restaurant","picture","breakPoint","createElement","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","Symbol","iterator","next","done","source","value","className","srcsets","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","push","DBHelper","imageUrlForRestaurant","err","return","length","join","append","image","src","alt","name","figureCaption","innerHTML","lazy","querySelectorAll","console","log","lazyLoad","i","isInViewport","getAttribute","removeAttribute","cleanLazy","Array","prototype","filter","call","l","el","rect","top","window","innerHeight","documentElement","clientHeight","innerWidth","clientWidth","event","func","addEventListener","setLazy","attachEvent","registerListener","restoDbname","reviewsDbname","objectStore","pendingReviewsID","open","indexedDB","onupgradeneeded","result","createObjectStore","keyPath","data","initDB","onsuccess","transaction","resto","store","put","query","db","tx","res","getAll","get","parseInt","callback","oncomplete","close","getRestoFromDB","fetch","DATABASE_URL","then","json","restaurants","storeRestoToDB","id","fetchRestaurants","error","find","r","cuisine","cuisine_type","results","neighborhood","neighborhoods","map","v","uniqueNeighborhoods","indexOf","cuisines","uniqueCuisines","dimension","google","maps","Marker","position","latlng","title","url","urlForRestaurant","animation","Animation","DROP","createIndex","initReviewsDB","forEach","index","marker","getReviewsFromDB","pendingReviews","getPendingReviewsByID","restoReviews","concat","reviews","slice","storeReviewsToDB","catch","review","JSON","parse","localStorage","getItem","existingEntries","setItem","stringify","getPendingReviews","numericID","pendingReview","restaurant_id","removeItem","handleModalReviews","modal","getElementById","btn","span","getElementsByClassName","onclick","display","style","target","initMap","fetchRestaurantFromURL","self","Map","center","scrollwheel","onload","fillBreadcrumb","mapMarkerForRestaurant","fetchRestaurantById","fetchReviewsByRestaurantID","fillRestaurantHTML","fillReviewsHTML","arguments","address","operatingHours","operating_hours","fillRestaurantHoursHTML","key","row","day","appendChild","time","hours","container","noReviews","fillReviewsList","ul","createReviewHTML","removeChild","firstChild","date","Date","createdAt","toDateString","li","rating","comments","breadcrumb","querySelector","currentPage","setAttribute","location","href","getParameterByName","decodeURIComponent","replace","regex","form","elements","body","sendReview","method","headers","Content-Type","addPendingReview","reset","Accept","finally","SWService","navigator","serviceWorker","indexController","this","register","reg","controller","waiting","updateReady","trackInstalling","installing","refreshing","reload","_dbPromise","_postsView","showingPosts","indexedDBName","messages","addPosts","reverse","worker","state","postMessage","action","swregister","registerServiceWorker"],"mappings":"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","file":"info.min.js","sourcesContent":["\n\nconst responsiveBreakPoints = [\n  {\n    media: {\n      minwidth: 0,\n      maxwidth: 500,\n    },\n    srcset: [\n      {\n        imgSuffix: 'small',\n        imgCondition: '450w',\n      },\n    ],\n    sizes: [],\n  }, {\n    media: {\n      minwidth: 501,\n      maxwidth: 850,\n    },\n    srcset: [\n      {\n        imgSuffix: 'medium',\n        imgCondition: '550w',\n      },\n    ],\n    sizes: [],\n  }, {\n    media: {\n      minwidth: 851,\n      maxwidth: null,\n    },\n    srcset: [\n      {\n        imgSuffix: 'large',\n        imgCondition: '800w',\n      },\n    ],\n    sizes: [],\n  },\n];\n\nconst responsiveImage = (restaurant) => {\n  const figure = document.createElement('figure');\n  const picture = document.createElement('picture');\n\n  for (const breakPoint of responsiveBreakPoints) {\n    const source = document.createElement('source');\n    source.className = 'lazy';\n\n    source.media = '';\n    if (breakPoint.media.maxwidth && breakPoint.media.minwidth) {\n      source.media += `(min-width: ${breakPoint.media.minwidth}px) and (max-width: ${breakPoint.media.maxwidth}px)`;\n    } else {\n      if (breakPoint.media.minwidth) { source.media += `(min-width: ${breakPoint.media.minwidth}px)`; }\n      if (breakPoint.media.maxwidth) { source.media += `(max-width: ${breakPoint.media.maxwidth}px)`; }\n    }\n\n    const srcsets = [];\n\n    for (const srcset of breakPoint.srcset) {\n      if (srcset.imgSuffix === 'small') { continue; }\n      srcsets.push(`${DBHelper.imageUrlForRestaurant(restaurant, srcset.imgSuffix)}  ${srcset.imgCondition}`);\n    }\n\n    // if there is src set Add\n    if (srcsets.length > 0) {\n      source.srcset = srcsets.join(srcsets, ',');\n      // source.dataset.srcset = srcsets.join(srcsets, ',');\n\n      picture.append(source);\n    }\n  }\n\n  const image = document.createElement('img');\n  image.className = 'restaurant-img';\n  image.src = DBHelper.imageUrlForRestaurant(restaurant, 'small');\n  // image.dataset.src = DBHelper.imageUrlForRestaurant(restaurant, 'small');\n  image.alt = `Image of the restaurant ${restaurant.name}`;\n  picture.append(image);\n\n  figure.append(picture);\n\n  const figureCaption = document.createElement('figcaption');\n  figureCaption.innerHTML = restaurant.name;\n  figure.append(figureCaption);\n\n  return figure;\n};\n\n//\nlet lazy = [];\n\n\nfunction setLazy() {\n  // document.getElementById('listing').removeChild(document.getElementById('viewMore'));\n  // document.getElementById('nextPage').removeAttribute('class');\n\n  lazy = document.querySelectorAll('img[data-src]');\n  console.log(`Found ${lazy.length} lazy images`);\n}\n\nfunction lazyLoad() {\n  lazy = document.querySelectorAll('img[data-src]');\n\n  for (let i = 0; i < lazy.length; i++) {\n    if (isInViewport(lazy[i])) {\n      if (lazy[i].getAttribute('data-src')) {\n        lazy[i].src = lazy[i].getAttribute('data-src');\n        lazy[i].removeAttribute('data-src');\n      }\n    }\n  }\n\n  cleanLazy();\n}\n\nfunction cleanLazy() {\n  lazy = Array.prototype.filter.call(lazy, l => l.getAttribute('data-src'));\n}\n\nfunction isInViewport(el) {\n  const rect = el.getBoundingClientRect();\n\n  return (\n    rect.bottom >= 0 &&\n        rect.right >= 0 &&\n        rect.top <= (window.innerHeight || document.documentElement.clientHeight) &&\n        rect.left <= (window.innerWidth || document.documentElement.clientWidth)\n  );\n}\n\nfunction registerListener(event, func) {\n  if (window.addEventListener) {\n    window.addEventListener(event, func);\n  } else {\n    window.attachEvent(`on${event}`, func);\n  }\n}\n\n\nregisterListener('load', setLazy);\nregisterListener('load', lazyLoad);\nregisterListener('scroll', lazyLoad);\nregisterListener('resize', lazyLoad);\n","/**\n * Common database helper functions.\n */\n\nconst restoDbname = 'restomws';\nconst reviewsDbname = 'reviewsmws';\nconst objectStore = 'mwsObjectStore';\nconst pendingReviewsID = 'pendingReviews';\n\n// eslint-disable-next-line\nclass DBHelper {\n  /**\n   * Database URL.\n   * Change this to restaurants.json file location on your server.\n   */\n  static get DATABASE_URL() {\n    const port = 1337; // Change this to your server port\n    return `http://localhost:${port}`;\n  }\n\n  // ===========================================\n  // Restaurants\n  // ===========================================\n\n  static initDB() {\n    // This works on all devices/browsers, and uses IndexedDBShim as a final fallback\n    const indexedDB = window.indexedDB; // eslint-disable-line\n\n    // Open (or create) the database\n    const open = indexedDB.open(restoDbname, 1);\n\n    // Create the schema\n    open.onupgradeneeded = function onupgradeneeded() {\n      const db = open.result;\n      db.createObjectStore(objectStore, { keyPath: 'id' });\n      // var index = store.createIndex(\"NameIndex\", [\"name.last\", \"name.first\"]);\n    };\n\n    return open;\n  }\n\n\n  static storeRestoToDB(data) {\n    const open = DBHelper.initDB();\n\n    open.onsuccess = function onsuccess() {\n      // Start a new transaction\n      const db = open.result;\n      const tx = db.transaction(objectStore, 'readwrite');\n      const store = tx.objectStore(objectStore);\n\n      data.forEach((resto) => {\n        store.put(resto);\n      });\n    };\n  }\n\n  static getRestoFromDB(query, callback) {\n    const open = DBHelper.initDB();\n\n    open.onsuccess = function onsuccess() {\n      // Start a new transaction\n      const db = open.result;\n      const tx = db.transaction(objectStore, 'readwrite');\n      const store = tx.objectStore(objectStore);\n\n      let res = store.getAll();\n      if (query) {\n        res = store.get(parseInt(query, 10));\n      }\n\n      res.onsuccess = function resonsuccess() {\n        callback(res.result);\n      };\n\n      // Close the db when the transaction is done\n      tx.oncomplete = function oncomplete() {\n        db.close();\n      };\n    };\n  }\n\n\n  // ===========================================\n  // ===========================================\n\n  /**\n   * Fetch all restaurants.\n   */\n  static fetchRestaurants(callback) {\n    DBHelper.getRestoFromDB(null, (data) => {\n      if (data) {\n        callback(null, data);\n      }\n\n      // eslint-disable-next-line\n      fetch(`${DBHelper.DATABASE_URL}/restaurants`).then(res => res.json()).then((restaurants) => {\n        callback(null, restaurants);\n        DBHelper.storeRestoToDB(restaurants);\n      }).catch((err) => {\n        const error = ('Request failed', err);\n        callback(error, null);\n      });\n    });\n  }\n\n\n  /**\n   * Fetch a restaurant by its ID.\n   */\n  static fetchRestaurantById(id, callback) {\n    // fetch all restaurants with proper error handling.\n    DBHelper.getRestoFromDB(id, (data) => {\n      if (data) {\n        callback(null, data);\n        return;\n      }\n\n      DBHelper.fetchRestaurants((error, restaurants) => {\n        if (error) {\n          callback(error, null);\n        } else {\n          const restaurant = restaurants.find(r => r.id === id);\n          if (restaurant) { // Got the restaurant\n            callback(null, restaurant);\n          } else { // Restaurant does not exist in the database\n            callback('Restaurant does not exist', null);\n          }\n        }\n      });\n    });\n  }\n\n  /**\n   * Fetch restaurants by a cuisine type with proper error handling.\n   */\n  static fetchRestaurantByCuisine(cuisine, callback) {\n    // Fetch all restaurants  with proper error handling\n    DBHelper.fetchRestaurants((error, restaurants) => {\n      if (error) {\n        callback(error, null);\n      } else {\n        // Filter restaurants to have only given cuisine type\n        const results = restaurants.filter(r => r.cuisine_type === cuisine);\n        callback(null, results);\n      }\n    });\n  }\n\n  /**\n   * Fetch restaurants by a neighborhood with proper error handling.\n   */\n  static fetchRestaurantByNeighborhood(neighborhood, callback) {\n    // Fetch all restaurants\n    DBHelper.fetchRestaurants((error, restaurants) => {\n      if (error) {\n        callback(error, null);\n      } else {\n        // Filter restaurants to have only given neighborhood\n        const results = restaurants.filter(r => r.neighborhood === neighborhood);\n        callback(null, results);\n      }\n    });\n  }\n\n  /**\n   * Fetch restaurants by a cuisine and a neighborhood with proper error handling.\n   */\n  static fetchRestaurantByCuisineAndNeighborhood(cuisine, neighborhood, callback) {\n    // Fetch all restaurants\n    DBHelper.fetchRestaurants((error, restaurants) => {\n      if (error) {\n        callback(error, null);\n      } else {\n        let results = restaurants;\n        if (cuisine !== 'all') { // filter by cuisine\n          results = results.filter(r => r.cuisine_type === cuisine);\n        }\n        if (neighborhood !== 'all') { // filter by neighborhood\n          results = results.filter(r => r.neighborhood === neighborhood);\n        }\n        callback(null, results);\n      }\n    });\n  }\n\n  /**\n   * Fetch all neighborhoods with proper error handling.\n   */\n  static fetchNeighborhoods(callback) {\n    // Fetch all restaurants\n    DBHelper.fetchRestaurants((error, restaurants) => {\n      if (error) {\n        callback(error, null);\n      } else {\n        // Get all neighborhoods from all restaurants\n        const neighborhoods = restaurants.map((v, i) => restaurants[i].neighborhood);\n        // Remove duplicates from neighborhoods\n        const uniqueNeighborhoods = neighborhoods.filter((v, i) => neighborhoods.indexOf(v) === i);\n        callback(null, uniqueNeighborhoods);\n      }\n    });\n  }\n\n  /**\n   * Fetch all cuisines with proper error handling.\n   */\n  static fetchCuisines(callback) {\n    // Fetch all restaurants\n    DBHelper.fetchRestaurants((error, restaurants) => {\n      if (error) {\n        callback(error, null);\n      } else {\n        // Get all cuisines from all restaurants\n        const cuisines = restaurants.map((v, i) => restaurants[i].cuisine_type);\n        // Remove duplicates from cuisines\n        const uniqueCuisines = cuisines.filter((v, i) => cuisines.indexOf(v) === i);\n        callback(null, uniqueCuisines);\n      }\n    });\n  }\n\n  /**\n   * Restaurant page URL.\n   */\n  static urlForRestaurant(restaurant) {\n    return (`./restaurant.html?id=${restaurant.id}`);\n  }\n\n  /**\n   * Restaurant image URL.\n   */\n  static imageUrlForRestaurant(restaurant, dimension) {\n    switch (dimension) {\n      case 'large':\n        return (`/img/${restaurant.id}-large.jpg`);\n      case 'medium':\n        return (`/img/${restaurant.id}-medium.jpg`);\n      default:\n        return (`/img/${restaurant.id}-small.jpg`);\n    }\n  }\n\n  /**\n   * Map marker for a restaurant.\n   */\n  static mapMarkerForRestaurant(restaurant, map) {\n    // eslint-disable-next-line\n    if (!window.google) { return; }\n\n    // eslint-disable-next-line\n    const marker = new google.maps.Marker({\n      position: restaurant.latlng,\n      title: restaurant.name,\n      url: DBHelper.urlForRestaurant(restaurant),\n      map,\n      animation: google.maps.Animation.DROP,//eslint-disable-line\n    });\n    // eslint-disable-next-line\n    return marker;\n  }\n\n\n  // ===========================================\n  // Reviews\n  // ===========================================\n\n  static initReviewsDB() {\n  // This works on all devices/browsers, and uses IndexedDBShim as a final fallback\n    const indexedDB = window.indexedDB; // eslint-disable-line\n\n    // Open (or create) the database\n    const open = indexedDB.open(reviewsDbname, 1);\n\n    // Create the schema\n    open.onupgradeneeded = function onupgradeneeded() {\n      const db = open.result;\n      const store = db.createObjectStore(objectStore, { keyPath: 'id' });\n      store.createIndex('RestaurantIDIndex', ['restaurant_id']);\n    };\n\n    return open;\n  }\n\n\n  static storeReviewsToDB(data) {\n    const open = DBHelper.initReviewsDB();\n\n    open.onsuccess = function onsuccess() {\n    // Start a new transaction\n      const db = open.result;\n      const tx = db.transaction(objectStore, 'readwrite');\n      const store = tx.objectStore(objectStore);\n\n      data.forEach((resto) => {\n        store.put(resto);\n      });\n    };\n  }\n\n  static getReviewsFromDB(query, callback) {\n    const open = DBHelper.initReviewsDB();\n\n    open.onsuccess = function onsuccess() {\n    // Start a new transaction\n      const db = open.result;\n      const tx = db.transaction(objectStore, 'readwrite');\n      const store = tx.objectStore(objectStore);\n      const index = store.index('RestaurantIDIndex');\n\n      let res;\n      if (query) {\n        res = index.getAll([parseInt(query, 10)]);\n      } else {\n        res = index.getAll();\n      }\n\n      res.onsuccess = function resonsuccess() {\n        callback(res.result);\n      };\n\n      // Close the db when the transaction is done\n      tx.oncomplete = function oncomplete() {\n        db.close();\n      };\n    };\n  }\n\n  /**\n   * Fetch all restaurants.\n   */\n  static fetchReviewsByRestaurantID(id, callback) {\n    DBHelper.getReviewsFromDB(id, (data) => {\n      if (data) {\n        let restoReviews = data.slice(0);\n        const pendingReviews = DBHelper.getPendingReviewsByID(id);\n        restoReviews = restoReviews.concat(pendingReviews);\n        callback(null, restoReviews);\n      }\n\n      // eslint-disable-next-line\n      fetch(`${DBHelper.DATABASE_URL}/reviews?restaurant_id=${id}`).then(res => res.json()).then((reviews) => {\n        let restoReviews = reviews.slice(0);\n        const pendingReviews = DBHelper.getPendingReviewsByID(id);\n        restoReviews = restoReviews.concat(pendingReviews);\n\n        callback(null, restoReviews);\n        DBHelper.storeReviewsToDB(reviews);\n      }).catch((err) => {\n        const error = ('Request failed', err);\n        callback(error, null);\n      });\n    });\n  }\n\n  static addPendingReview(review) {\n    // Parse any JSON previously stored in allEntries\n    let existingEntries = JSON.parse(localStorage.getItem(pendingReviewsID));\n    if (existingEntries == null) existingEntries = [];\n    existingEntries.push(review);\n    localStorage.setItem(pendingReviewsID, JSON.stringify(existingEntries));\n  }\n\n  static getPendingReviews(review) {\n    // Parse any JSON previously stored in allEntries\n    let existingEntries = JSON.parse(localStorage.getItem(pendingReviewsID));\n    if (existingEntries == null) {\n      existingEntries = [];\n    }\n    return existingEntries;\n  }\n\n  static getPendingReviewsByID(id) {\n    const pendingReviews = DBHelper.getPendingReviews();\n    const numericID = parseInt(id, 10);\n\n    const restoReviews = [];\n\n    pendingReviews.forEach((pendingReview) => {\n      if (pendingReview.restaurant_id === numericID) {\n        restoReviews.push(pendingReview);\n      }\n    });\n    return restoReviews;\n  }\n\n  static ClearPendingReview() {\n    // Parse any JSON previously stored in allEntries\n    localStorage.removeItem(pendingReviewsID);\n  }\n}\n","window.addEventListener('online', () => {\n\n});\nwindow.addEventListener('offline', () => {\n\n});\n","let restaurant;\nlet map;\n\n/**\n * Initialize Google map, called from HTML.\n */\nwindow.initMap = () => {\n  fetchRestaurantFromURL((error, restaurant) => {\n    if (error) { // Got an error!\n      console.error(error);\n    } else {\n      self.map = new google.maps.Map(document.getElementById('map'), {\n        zoom: 16,\n        center: restaurant.latlng,\n        scrollwheel: false,\n      });\n      fillBreadcrumb();\n      DBHelper.mapMarkerForRestaurant(self.restaurant, self.map);\n    }\n  });\n};\n\nwindow.onload = () => {\n  if (!window.google) {\n    fetchRestaurantFromURL((error, restaurant) => {\n      if (error) { // Got an error!\n        console.error(error);\n      } else {\n        fillBreadcrumb();\n        DBHelper.mapMarkerForRestaurant(self.restaurant, self.map);\n      }\n    });\n  }\n};\n\nfunction handleModalReviews() {\n  // Get the modal\n  const modal = document.getElementById('review-modal');\n\n  // Get the button that opens the modal\n  const btn = document.getElementById('open-review');\n\n  // Get the <span> element that closes the modal\n  const span = document.getElementsByClassName('close')[0];\n\n  // When the user clicks the button, open the modal\n  btn.onclick = function () {\n    modal.style.display = 'block';\n  };\n\n  // When the user clicks on <span> (x), close the modal\n  span.onclick = function () {\n    modal.style.display = 'none';\n  };\n\n  // When the user clicks anywhere outside of the modal, close it\n  window.onclick = function (event) {\n    if (event.target == modal) {\n      modal.style.display = 'none';\n    }\n  };\n}\n\nhandleModalReviews();\n\n/**\n * Get current restaurant from page URL.\n */\nconst fetchRestaurantFromURL = (callback) => {\n  if (self.restaurant) { // restaurant already fetched!\n    callback(null, self.restaurant);\n    return;\n  }\n  const id = getParameterByName('id');\n  if (!id) { // no id found in URL\n    console.log('[[IDNOTFOUND]]', id);\n    const error = 'No restaurant id in URL';\n    callback(error, null);\n  } else {\n    DBHelper.fetchRestaurantById(id, (error, restaurant) => {\n      self.restaurant = restaurant;\n      if (!restaurant) {\n        console.error(error);\n        return;\n      }\n      fillRestaurantHTML();\n      callback(null, restaurant);\n    });\n\n    DBHelper.fetchReviewsByRestaurantID(id, (error, reviews) => {\n      console.log('reviews', id, reviews, error);\n      if (!reviews) {\n        console.error(error);\n        return;\n      }\n      restaurant.reviews = reviews;\n      // fill reviews\n      fillReviewsHTML(restaurant.reviews);\n    });\n  }\n};\n\n/**\n * Create restaurant HTML and add it to the webpage\n */\nconst fillRestaurantHTML = (restaurant = self.restaurant) => {\n  const name = document.getElementById('restaurant-name');\n  name.innerHTML = restaurant.name;\n\n  const address = document.getElementById('restaurant-address');\n  address.innerHTML = restaurant.address;\n\n  // const image = document.getElementById('restaurant-img');\n  // image.className = 'restaurant-img'\n  // image.src = DBHelper.imageUrlForRestaurant(restaurant);\n\n  const image = responsiveImage(restaurant);\n  const container = document.getElementById('restaurant-container');\n  const figure = document.getElementById('restaurant-img');\n  figure.innerHTML = image.innerHTML;\n  // container.insertBefore(image, container.children[1])\n\n  const cuisine = document.getElementById('restaurant-cuisine');\n  cuisine.innerHTML = restaurant.cuisine_type;\n\n  // fill operating hours\n  if (restaurant.operating_hours) {\n    fillRestaurantHoursHTML();\n  }\n};\n\n/**\n * Create restaurant operating hours HTML table and add it to the webpage.\n */\nconst fillRestaurantHoursHTML = (operatingHours = self.restaurant.operating_hours) => {\n  const hours = document.getElementById('restaurant-hours');\n  for (const key in operatingHours) {\n    const row = document.createElement('tr');\n\n    const day = document.createElement('td');\n    day.innerHTML = key;\n    row.appendChild(day);\n\n    const time = document.createElement('td');\n    time.innerHTML = operatingHours[key];\n    row.appendChild(time);\n\n    hours.appendChild(row);\n  }\n};\n\n/**\n * Create all reviews HTML and add them to the webpage.\n */\nconst fillReviewsHTML = (reviews = self.restaurant.reviews) => {\n  const container = document.getElementById('reviews-container');\n\n  const title = document.createElement('h3');\n  title.innerHTML = 'Reviews';\n  container.appendChild(title);\n\n  if (!reviews) {\n    const noReviews = document.createElement('p');\n    noReviews.innerHTML = 'No reviews yet!';\n    container.appendChild(noReviews);\n  }\n\n  fillReviewsList(reviews);\n};\n\nfunction fillReviewsList(reviews) {\n  const container = document.getElementById('reviews-container');\n  const ul = document.getElementById('reviews-list');\n\n  // reset REVIEWS\n  while (ul.firstChild) {\n    ul.removeChild(ul.firstChild);\n  }\n\n  reviews.forEach((review) => {\n    ul.appendChild(createReviewHTML(review));\n  });\n  container.appendChild(ul);\n}\n/**\n * Create review HTML and add it to the webpage.\n */\nconst createReviewHTML = (review) => {\n  const li = document.createElement('li');\n  const name = document.createElement('p');\n  name.innerHTML = review.name;\n  li.appendChild(name);\n\n  const date = document.createElement('p');\n  date.innerHTML = new Date(review.createdAt).toDateString();\n  li.appendChild(date);\n\n  const rating = document.createElement('p');\n  rating.innerHTML = `Rating: ${review.rating}`;\n  li.appendChild(rating);\n\n  const comments = document.createElement('p');\n  comments.innerHTML = review.comments;\n  li.appendChild(comments);\n\n  return li;\n};\n\n/**\n * Add restaurant name to the breadcrumb navigation menu\n */\nconst fillBreadcrumb = (restaurant = self.restaurant) => {\n  const breadcrumb = document.querySelector('#navBreadcrumb ul');\n  const li = document.createElement('li');\n  const currentPage = document.createElement('a');\n  currentPage.innerHTML = restaurant.name;\n  currentPage.setAttribute('href', location.href);\n  currentPage.setAttribute('aria-current', 'page');\n  li.appendChild(currentPage);\n  breadcrumb.appendChild(li);\n};\n\n/**\n * Get a parameter by name from page URL.\n */\nconst getParameterByName = (name, url) => {\n  if (!url) {\n    url = window.location.href;\n  }\n  name = name.replace(/[\\[\\]]/g, '\\\\$&');\n  const regex = new RegExp(`[?&]${name}(=([^&#]*)|&|#|$)`),\n    results = regex.exec(url);\n  if (!results) {\n    return null;\n  }\n  if (!results[2]) {\n    return '';\n  }\n  return decodeURIComponent(results[2].replace(/\\+/g, ' '));\n};\n\n/**\n * Send Review\n */\n\nconst sendReview = () => {\n  const modal = document.getElementById('review-modal');\n  const form = document.querySelector('#review-form');\n  const id = parseInt(getParameterByName('id'), 10);\n  const name = form.elements[0].value;\n  const rating = form.elements[1].value;\n  const comments = form.elements[2].value;\n\n  if (!id || !name || !rating || !comments) {\n    console.log('one value is missing');\n    return;\n  }\n\n  const body = {\n    createdAt: new Date().getTime(),\n    restaurant_id: id,\n    name,\n    rating,\n    comments,\n  };\n  fetch('http://localhost:1337/reviews/', {\n    method: 'POST',\n    headers: {\n      Accept: 'application/json',\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify(body),\n  }).then(res => res.json())\n    .catch((err) => {\n      console.log('[errorBeforeJSON]', err);\n      DBHelper.addPendingReview(body);\n    })\n    .finally(() => {\n      // Get the modal\n      form.reset();\n      modal.style.display = 'none';\n      console.log(id);\n      DBHelper.fetchReviewsByRestaurantID(id, (error, reviews) => {\n        console.log('reviews', reviews);\n        if (!reviews) {\n          console.error(error);\n          return;\n        }\n        restaurant.reviews = reviews;\n\n        // fill reviews\n        fillReviewsList(restaurant.reviews);\n      });\n    });\n};\n","class SWService {\n  registerServiceWorker() {\n    if (!navigator.serviceWorker) return;\n\n    const indexController = this;\n\n    navigator.serviceWorker.register('/sw.js').then((reg) => {\n      if (!navigator.serviceWorker.controller) {\n        return;\n      }\n\n      if (reg.waiting) {\n        indexController.updateReady(reg.waiting);\n        return;\n      }\n\n      if (reg.installing) {\n        indexController.trackInstalling(reg.installing);\n        return;\n      }\n\n      reg.addEventListener('updatefound', () => {\n        indexController.trackInstalling(reg.installing);\n      });\n    });\n\n    // Ensure refresh is only called once.\n    // This works around a bug in \"force update on reload\".\n    let refreshing;\n    navigator.serviceWorker.addEventListener('controllerchange', () => {\n      if (refreshing) return;\n      window.location.reload();\n      refreshing = true;\n    });\n  }\n\n  showCachedMessages() {\n    const indexController = this;\n\n    return this._dbPromise.then((db) => {\n      // if we're already showing posts, eg shift-refresh\n      // or the very first load, there's no point fetching\n      // posts from IDB\n      if (!db || indexController._postsView.showingPosts()) return;\n\n      const index = db.transaction(indexedDBName)\n        .objectStore(indexedDBName).index('by-date');\n\n      return index.getAll().then((messages) => {\n        indexController._postsView.addPosts(messages.reverse());\n      });\n    });\n  }\n\n  trackInstalling(worker) {\n    const indexController = this;\n    worker.addEventListener('statechange', () => {\n      if (worker.state == 'installed') {\n        indexController.updateReady(worker);\n      }\n    });\n  }\n\n\n  updateReady(worker) {\n    worker.postMessage({\n      action: 'skipWaiting',\n    });\n  }\n}\n\n\nconst swregister = new SWService();\nswregister.registerServiceWorker();\n"]}
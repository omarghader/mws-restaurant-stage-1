{"version":3,"sources":["shared.js","dbhelper.js","main.js","swregister.js"],"names":["responsiveBreakPoints","media","minwidth","maxwidth","imgSuffix","imgCondition","sizes","srcset","responsiveImage","figure","document","restaurant","picture","breakPoint","createElement","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","Symbol","iterator","next","done","source","value","className","srcsets","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","push","DBHelper","imageUrlForRestaurant","err","return","length","join","append","image","src","alt","name","figureCaption","innerHTML","lazy","querySelectorAll","console","log","lazyLoad","i","isInViewport","getAttribute","removeAttribute","cleanLazy","Array","prototype","filter","call","l","el","rect","top","window","innerHeight","documentElement","clientHeight","innerWidth","clientWidth","event","func","addEventListener","setLazy","attachEvent","registerListener","restoDbname","reviewsDbname","objectStore","pendingReviewsID","open","indexedDB","onupgradeneeded","result","createObjectStore","keyPath","data","initDB","onsuccess","transaction","resto","store","put","query","db","tx","res","getAll","get","parseInt","callback","oncomplete","close","getRestoFromDB","fetch","DATABASE_URL","then","json","restaurants","storeRestoToDB","id","fetchRestaurants","error","find","r","cuisine","cuisine_type","results","neighborhood","neighborhoods","map","v","uniqueNeighborhoods","indexOf","cuisines","uniqueCuisines","dimension","google","maps","Marker","position","latlng","title","url","urlForRestaurant","animation","Animation","DROP","createIndex","initReviewsDB","forEach","index","marker","getReviewsFromDB","pendingReviews","getPendingReviewsByID","restoReviews","concat","reviews","slice","storeReviewsToDB","catch","review","JSON","parse","localStorage","getItem","existingEntries","setItem","stringify","getPendingReviews","numericID","pendingReview","restaurant_id","removeItem","updateRestaurants","fetchNeighborhoods","fillNeighborhoodsHTML","arguments","self","select","getElementById","option","fetchCuisines","fillCuisinesHTML","querySelector","s","setAttribute","body","appendChild","showMap","Map","initMap","center","lat","parentNode","cSelect","nSelect","cIndex","selectedIndex","nIndex","item","fetchRestaurantByCuisineAndNeighborhood","resetRestaurants","fillRestaurantsHTML","m","setMap","markers","ul","addMarkersToMap","createRestaurantHTML","li","address","more","href","mapMarkerForRestaurant","addListener","location","SWService","navigator","serviceWorker","indexController","this","register","reg","controller","waiting","updateReady","trackInstalling","installing","refreshing","reload","_dbPromise","_postsView","showingPosts","indexedDBName","messages","addPosts","reverse","worker","state","postMessage","action","swregister","registerServiceWorker"],"mappings":"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","file":"home.min.js","sourcesContent":["\n\nconst responsiveBreakPoints = [\n  {\n    media: {\n      minwidth: 0,\n      maxwidth: 500,\n    },\n    srcset: [\n      {\n        imgSuffix: 'small',\n        imgCondition: '450w',\n      },\n    ],\n    sizes: [],\n  }, {\n    media: {\n      minwidth: 501,\n      maxwidth: 850,\n    },\n    srcset: [\n      {\n        imgSuffix: 'medium',\n        imgCondition: '550w',\n      },\n    ],\n    sizes: [],\n  }, {\n    media: {\n      minwidth: 851,\n      maxwidth: null,\n    },\n    srcset: [\n      {\n        imgSuffix: 'large',\n        imgCondition: '800w',\n      },\n    ],\n    sizes: [],\n  },\n];\n\nconst responsiveImage = (restaurant) => {\n  const figure = document.createElement('figure');\n  const picture = document.createElement('picture');\n\n  for (const breakPoint of responsiveBreakPoints) {\n    const source = document.createElement('source');\n    source.className = 'lazy';\n\n    source.media = '';\n    if (breakPoint.media.maxwidth && breakPoint.media.minwidth) {\n      source.media += `(min-width: ${breakPoint.media.minwidth}px) and (max-width: ${breakPoint.media.maxwidth}px)`;\n    } else {\n      if (breakPoint.media.minwidth) { source.media += `(min-width: ${breakPoint.media.minwidth}px)`; }\n      if (breakPoint.media.maxwidth) { source.media += `(max-width: ${breakPoint.media.maxwidth}px)`; }\n    }\n\n    const srcsets = [];\n\n    for (const srcset of breakPoint.srcset) {\n      if (srcset.imgSuffix === 'small') { continue; }\n      srcsets.push(`${DBHelper.imageUrlForRestaurant(restaurant, srcset.imgSuffix)}  ${srcset.imgCondition}`);\n    }\n\n    // if there is src set Add\n    if (srcsets.length > 0) {\n      source.srcset = srcsets.join(srcsets, ',');\n      // source.dataset.srcset = srcsets.join(srcsets, ',');\n\n      picture.append(source);\n    }\n  }\n\n  const image = document.createElement('img');\n  image.className = 'restaurant-img';\n  image.src = DBHelper.imageUrlForRestaurant(restaurant, 'small');\n  // image.dataset.src = DBHelper.imageUrlForRestaurant(restaurant, 'small');\n  image.alt = `Image of the restaurant ${restaurant.name}`;\n  picture.append(image);\n\n  figure.append(picture);\n\n  const figureCaption = document.createElement('figcaption');\n  figureCaption.innerHTML = restaurant.name;\n  figure.append(figureCaption);\n\n  return figure;\n};\n\n//\nlet lazy = [];\n\n\nfunction setLazy() {\n  // document.getElementById('listing').removeChild(document.getElementById('viewMore'));\n  // document.getElementById('nextPage').removeAttribute('class');\n\n  lazy = document.querySelectorAll('img[data-src]');\n  console.log(`Found ${lazy.length} lazy images`);\n}\n\nfunction lazyLoad() {\n  lazy = document.querySelectorAll('img[data-src]');\n\n  for (let i = 0; i < lazy.length; i++) {\n    if (isInViewport(lazy[i])) {\n      if (lazy[i].getAttribute('data-src')) {\n        lazy[i].src = lazy[i].getAttribute('data-src');\n        lazy[i].removeAttribute('data-src');\n      }\n    }\n  }\n\n  cleanLazy();\n}\n\nfunction cleanLazy() {\n  lazy = Array.prototype.filter.call(lazy, l => l.getAttribute('data-src'));\n}\n\nfunction isInViewport(el) {\n  const rect = el.getBoundingClientRect();\n\n  return (\n    rect.bottom >= 0 &&\n        rect.right >= 0 &&\n        rect.top <= (window.innerHeight || document.documentElement.clientHeight) &&\n        rect.left <= (window.innerWidth || document.documentElement.clientWidth)\n  );\n}\n\nfunction registerListener(event, func) {\n  if (window.addEventListener) {\n    window.addEventListener(event, func);\n  } else {\n    window.attachEvent(`on${event}`, func);\n  }\n}\n\n\nregisterListener('load', setLazy);\nregisterListener('load', lazyLoad);\nregisterListener('scroll', lazyLoad);\nregisterListener('resize', lazyLoad);\n","/**\n * Common database helper functions.\n */\n\nconst restoDbname = 'restomws';\nconst reviewsDbname = 'reviewsmws';\nconst objectStore = 'mwsObjectStore';\nconst pendingReviewsID = 'pendingReviews';\n\n// eslint-disable-next-line\nclass DBHelper {\n  /**\n   * Database URL.\n   * Change this to restaurants.json file location on your server.\n   */\n  static get DATABASE_URL() {\n    const port = 1337; // Change this to your server port\n    return `http://localhost:${port}`;\n  }\n\n  // ===========================================\n  // Restaurants\n  // ===========================================\n\n  static initDB() {\n    // This works on all devices/browsers, and uses IndexedDBShim as a final fallback\n    const indexedDB = window.indexedDB; // eslint-disable-line\n\n    // Open (or create) the database\n    const open = indexedDB.open(restoDbname, 1);\n\n    // Create the schema\n    open.onupgradeneeded = function onupgradeneeded() {\n      const db = open.result;\n      db.createObjectStore(objectStore, { keyPath: 'id' });\n      // var index = store.createIndex(\"NameIndex\", [\"name.last\", \"name.first\"]);\n    };\n\n    return open;\n  }\n\n\n  static storeRestoToDB(data) {\n    const open = DBHelper.initDB();\n\n    open.onsuccess = function onsuccess() {\n      // Start a new transaction\n      const db = open.result;\n      const tx = db.transaction(objectStore, 'readwrite');\n      const store = tx.objectStore(objectStore);\n\n      data.forEach((resto) => {\n        store.put(resto);\n      });\n    };\n  }\n\n  static getRestoFromDB(query, callback) {\n    const open = DBHelper.initDB();\n\n    open.onsuccess = function onsuccess() {\n      // Start a new transaction\n      const db = open.result;\n      const tx = db.transaction(objectStore, 'readwrite');\n      const store = tx.objectStore(objectStore);\n\n      let res = store.getAll();\n      if (query) {\n        res = store.get(parseInt(query, 10));\n      }\n\n      res.onsuccess = function resonsuccess() {\n        callback(res.result);\n      };\n\n      // Close the db when the transaction is done\n      tx.oncomplete = function oncomplete() {\n        db.close();\n      };\n    };\n  }\n\n\n  // ===========================================\n  // ===========================================\n\n  /**\n   * Fetch all restaurants.\n   */\n  static fetchRestaurants(callback) {\n    DBHelper.getRestoFromDB(null, (data) => {\n      if (data) {\n        callback(null, data);\n      }\n\n      // eslint-disable-next-line\n      fetch(`${DBHelper.DATABASE_URL}/restaurants`).then(res => res.json()).then((restaurants) => {\n        callback(null, restaurants);\n        DBHelper.storeRestoToDB(restaurants);\n      }).catch((err) => {\n        const error = ('Request failed', err);\n        callback(error, null);\n      });\n    });\n  }\n\n\n  /**\n   * Fetch a restaurant by its ID.\n   */\n  static fetchRestaurantById(id, callback) {\n    // fetch all restaurants with proper error handling.\n    DBHelper.getRestoFromDB(id, (data) => {\n      if (data) {\n        callback(null, data);\n        return;\n      }\n\n      DBHelper.fetchRestaurants((error, restaurants) => {\n        if (error) {\n          callback(error, null);\n        } else {\n          const restaurant = restaurants.find(r => r.id === id);\n          if (restaurant) { // Got the restaurant\n            callback(null, restaurant);\n          } else { // Restaurant does not exist in the database\n            callback('Restaurant does not exist', null);\n          }\n        }\n      });\n    });\n  }\n\n  /**\n   * Fetch restaurants by a cuisine type with proper error handling.\n   */\n  static fetchRestaurantByCuisine(cuisine, callback) {\n    // Fetch all restaurants  with proper error handling\n    DBHelper.fetchRestaurants((error, restaurants) => {\n      if (error) {\n        callback(error, null);\n      } else {\n        // Filter restaurants to have only given cuisine type\n        const results = restaurants.filter(r => r.cuisine_type === cuisine);\n        callback(null, results);\n      }\n    });\n  }\n\n  /**\n   * Fetch restaurants by a neighborhood with proper error handling.\n   */\n  static fetchRestaurantByNeighborhood(neighborhood, callback) {\n    // Fetch all restaurants\n    DBHelper.fetchRestaurants((error, restaurants) => {\n      if (error) {\n        callback(error, null);\n      } else {\n        // Filter restaurants to have only given neighborhood\n        const results = restaurants.filter(r => r.neighborhood === neighborhood);\n        callback(null, results);\n      }\n    });\n  }\n\n  /**\n   * Fetch restaurants by a cuisine and a neighborhood with proper error handling.\n   */\n  static fetchRestaurantByCuisineAndNeighborhood(cuisine, neighborhood, callback) {\n    // Fetch all restaurants\n    DBHelper.fetchRestaurants((error, restaurants) => {\n      if (error) {\n        callback(error, null);\n      } else {\n        let results = restaurants;\n        if (cuisine !== 'all') { // filter by cuisine\n          results = results.filter(r => r.cuisine_type === cuisine);\n        }\n        if (neighborhood !== 'all') { // filter by neighborhood\n          results = results.filter(r => r.neighborhood === neighborhood);\n        }\n        callback(null, results);\n      }\n    });\n  }\n\n  /**\n   * Fetch all neighborhoods with proper error handling.\n   */\n  static fetchNeighborhoods(callback) {\n    // Fetch all restaurants\n    DBHelper.fetchRestaurants((error, restaurants) => {\n      if (error) {\n        callback(error, null);\n      } else {\n        // Get all neighborhoods from all restaurants\n        const neighborhoods = restaurants.map((v, i) => restaurants[i].neighborhood);\n        // Remove duplicates from neighborhoods\n        const uniqueNeighborhoods = neighborhoods.filter((v, i) => neighborhoods.indexOf(v) === i);\n        callback(null, uniqueNeighborhoods);\n      }\n    });\n  }\n\n  /**\n   * Fetch all cuisines with proper error handling.\n   */\n  static fetchCuisines(callback) {\n    // Fetch all restaurants\n    DBHelper.fetchRestaurants((error, restaurants) => {\n      if (error) {\n        callback(error, null);\n      } else {\n        // Get all cuisines from all restaurants\n        const cuisines = restaurants.map((v, i) => restaurants[i].cuisine_type);\n        // Remove duplicates from cuisines\n        const uniqueCuisines = cuisines.filter((v, i) => cuisines.indexOf(v) === i);\n        callback(null, uniqueCuisines);\n      }\n    });\n  }\n\n  /**\n   * Restaurant page URL.\n   */\n  static urlForRestaurant(restaurant) {\n    return (`./restaurant.html?id=${restaurant.id}`);\n  }\n\n  /**\n   * Restaurant image URL.\n   */\n  static imageUrlForRestaurant(restaurant, dimension) {\n    switch (dimension) {\n      case 'large':\n        return (`/img/${restaurant.id}-large.jpg`);\n      case 'medium':\n        return (`/img/${restaurant.id}-medium.jpg`);\n      default:\n        return (`/img/${restaurant.id}-small.jpg`);\n    }\n  }\n\n  /**\n   * Map marker for a restaurant.\n   */\n  static mapMarkerForRestaurant(restaurant, map) {\n    // eslint-disable-next-line\n    if (!window.google) { return; }\n\n    // eslint-disable-next-line\n    const marker = new google.maps.Marker({\n      position: restaurant.latlng,\n      title: restaurant.name,\n      url: DBHelper.urlForRestaurant(restaurant),\n      map,\n      animation: google.maps.Animation.DROP,//eslint-disable-line\n    });\n    // eslint-disable-next-line\n    return marker;\n  }\n\n\n  // ===========================================\n  // Reviews\n  // ===========================================\n\n  static initReviewsDB() {\n  // This works on all devices/browsers, and uses IndexedDBShim as a final fallback\n    const indexedDB = window.indexedDB; // eslint-disable-line\n\n    // Open (or create) the database\n    const open = indexedDB.open(reviewsDbname, 1);\n\n    // Create the schema\n    open.onupgradeneeded = function onupgradeneeded() {\n      const db = open.result;\n      const store = db.createObjectStore(objectStore, { keyPath: 'id' });\n      store.createIndex('RestaurantIDIndex', ['restaurant_id']);\n    };\n\n    return open;\n  }\n\n\n  static storeReviewsToDB(data) {\n    const open = DBHelper.initReviewsDB();\n\n    open.onsuccess = function onsuccess() {\n    // Start a new transaction\n      const db = open.result;\n      const tx = db.transaction(objectStore, 'readwrite');\n      const store = tx.objectStore(objectStore);\n\n      data.forEach((resto) => {\n        store.put(resto);\n      });\n    };\n  }\n\n  static getReviewsFromDB(query, callback) {\n    const open = DBHelper.initReviewsDB();\n\n    open.onsuccess = function onsuccess() {\n    // Start a new transaction\n      const db = open.result;\n      const tx = db.transaction(objectStore, 'readwrite');\n      const store = tx.objectStore(objectStore);\n      const index = store.index('RestaurantIDIndex');\n\n      let res;\n      if (query) {\n        res = index.getAll([parseInt(query, 10)]);\n      } else {\n        res = index.getAll();\n      }\n\n      res.onsuccess = function resonsuccess() {\n        callback(res.result);\n      };\n\n      // Close the db when the transaction is done\n      tx.oncomplete = function oncomplete() {\n        db.close();\n      };\n    };\n  }\n\n  /**\n   * Fetch all restaurants.\n   */\n  static fetchReviewsByRestaurantID(id, callback) {\n    DBHelper.getReviewsFromDB(id, (data) => {\n      if (data) {\n        let restoReviews = data.slice(0);\n        const pendingReviews = DBHelper.getPendingReviewsByID(id);\n        restoReviews = restoReviews.concat(pendingReviews);\n        callback(null, restoReviews);\n      }\n\n      // eslint-disable-next-line\n      fetch(`${DBHelper.DATABASE_URL}/reviews?restaurant_id=${id}`).then(res => res.json()).then((reviews) => {\n        let restoReviews = reviews.slice(0);\n        const pendingReviews = DBHelper.getPendingReviewsByID(id);\n        restoReviews = restoReviews.concat(pendingReviews);\n\n        callback(null, restoReviews);\n        DBHelper.storeReviewsToDB(reviews);\n      }).catch((err) => {\n        const error = ('Request failed', err);\n        callback(error, null);\n      });\n    });\n  }\n\n  static addPendingReview(review) {\n    // Parse any JSON previously stored in allEntries\n    let existingEntries = JSON.parse(localStorage.getItem(pendingReviewsID));\n    if (existingEntries == null) existingEntries = [];\n    existingEntries.push(review);\n    localStorage.setItem(pendingReviewsID, JSON.stringify(existingEntries));\n  }\n\n  static getPendingReviews(review) {\n    // Parse any JSON previously stored in allEntries\n    let existingEntries = JSON.parse(localStorage.getItem(pendingReviewsID));\n    if (existingEntries == null) {\n      existingEntries = [];\n    }\n    return existingEntries;\n  }\n\n  static getPendingReviewsByID(id) {\n    const pendingReviews = DBHelper.getPendingReviews();\n    const numericID = parseInt(id, 10);\n\n    const restoReviews = [];\n\n    pendingReviews.forEach((pendingReview) => {\n      if (pendingReview.restaurant_id === numericID) {\n        restoReviews.push(pendingReview);\n      }\n    });\n    return restoReviews;\n  }\n\n  static ClearPendingReview() {\n    // Parse any JSON previously stored in allEntries\n    localStorage.removeItem(pendingReviewsID);\n  }\n}\n","let restaurants,\n  neighborhoods,\n  cuisines;\nlet map;\nconst markers = [];\n\n/**\n * Fetch neighborhoods and cuisines as soon as the page is loaded.\n */\ndocument.addEventListener('DOMContentLoaded', (event) => {\n  updateRestaurants();\n  fetchNeighborhoods();\n  fetchCuisines();\n});\n\n\n/**\n * Fetch all neighborhoods and set their HTML.\n */\nconst fetchNeighborhoods = () => {\n  DBHelper.fetchNeighborhoods((error, neighborhoods) => {\n    if (error) { // Got an error\n      console.error(error);\n    } else {\n      self.neighborhoods = neighborhoods;\n      fillNeighborhoodsHTML();\n    }\n  });\n};\n\n/**\n * Set neighborhoods HTML.\n */\nconst fillNeighborhoodsHTML = (neighborhoods = self.neighborhoods) => {\n  const select = document.getElementById('neighborhoods-select');\n  neighborhoods.forEach((neighborhood) => {\n    const option = document.createElement('option');\n    option.innerHTML = neighborhood;\n    option.value = neighborhood;\n\n    // Accessibility\n    option.setAttribute('role', 'option');\n    select.append(option);\n  });\n};\n\n/**\n * Fetch all cuisines and set their HTML.\n */\nconst fetchCuisines = () => {\n  DBHelper.fetchCuisines((error, cuisines) => {\n    if (error) { // Got an error!\n      console.error(error);\n    } else {\n      self.cuisines = cuisines;\n      fillCuisinesHTML();\n    }\n  });\n};\n\n/**\n * Set cuisines HTML.\n */\nconst fillCuisinesHTML = (cuisines = self.cuisines) => {\n  const select = document.getElementById('cuisines-select');\n\n  cuisines.forEach((cuisine) => {\n    const option = document.createElement('option');\n    option.innerHTML = cuisine;\n    option.value = cuisine;\n    select.append(option);\n  });\n};\n\n/**\n * Initialize Google map, called from HTML.\n */\n\ndocument.querySelector('.show-map').addEventListener('click', () => {\n  const s = document.createElement('script');\n  s.setAttribute('src', 'https://maps.googleapis.com/maps/api/js?force=lite&key=AIzaSyAZGXODnOvH6vOy8rR8dl9LvRPcsdeJ7bc&libraries=places&callback=initMap');\n  s.setAttribute('defer', 'true');\n  s.setAttribute('async', 'true');\n  document.body.appendChild(s);\n  const showMap = document.querySelector('.show-map');\n  showMap.parentNode.removeChild(showMap);\n});\n\n\nwindow.initMap = () => {\n  const loc = {\n    lat: 40.722216,\n    lng: -73.987501,\n  };\n  self.map = new google.maps.Map(document.getElementById('map'), {\n    zoom: 12,\n    center: loc,\n    scrollwheel: false,\n  });\n\n  updateRestaurants();\n};\n\n/**\n * Update page and map for current restaurants.\n */\nconst updateRestaurants = () => {\n  const cSelect = document.getElementById('cuisines-select');\n  const nSelect = document.getElementById('neighborhoods-select');\n\n  const cIndex = cSelect.selectedIndex;\n  const nIndex = nSelect.selectedIndex;\n\n  const cuisine = cSelect[cIndex].value;\n  const neighborhood = nSelect[nIndex].value;\n\n  // Accessibility\n  if (cIndex > 0) {\n    cSelect.querySelectorAll('option').forEach((item, index) => {\n      if (index === cIndex) {\n        item.setAttribute('aria-selected', 'true');\n      } else {\n        item.removeAttribute('aria-selected');\n      }\n    });\n  }\n\n  if (nIndex > 0) {\n    nSelect.querySelectorAll('option').forEach((item, index) => {\n      if (index === nIndex) {\n        item.setAttribute('aria-selected', 'true');\n      } else {\n        item.removeAttribute('aria-selected');\n      }\n    });\n  }\n\n  DBHelper.fetchRestaurantByCuisineAndNeighborhood(cuisine, neighborhood, (error, restaurants) => {\n    if (error) { // Got an error!\n      console.error(error);\n    } else {\n      resetRestaurants(restaurants);\n      fillRestaurantsHTML();\n    }\n  });\n};\n\n/**\n * Clear current restaurants, their HTML and remove their map markers.\n */\nconst resetRestaurants = (restaurants) => {\n  // Remove all restaurants\n  self.restaurants = [];\n  const ul = document.getElementById('restaurants-list');\n  ul.innerHTML = '';\n\n  // Remove all map markers\n  self.markers.forEach(m => m.setMap(null));\n  self.markers = [];\n  self.restaurants = restaurants;\n};\n\n/**\n * Create all restaurants HTML and add them to the webpage.\n */\nconst fillRestaurantsHTML = (restaurants = self.restaurants) => {\n  const ul = document.getElementById('restaurants-list');\n  restaurants.forEach((restaurant, index) => {\n    ul.append(createRestaurantHTML(restaurant, index));\n  });\n  if (window.google) {\n    addMarkersToMap();\n  }\n};\n\n/**\n * Create restaurant HTML.\n */\nconst createRestaurantHTML = (restaurant, index) => {\n  const li = document.createElement('li');\n\n  const figure = document.createElement('figure');\n  const picture = document.createElement('picture');\n\n  for (const breakPoint of responsiveBreakPoints) {\n    const source = document.createElement('source');\n    source.media = '';\n    if (breakPoint.media.maxwidth && breakPoint.media.minwidth) { source.media += `(min-width: ${breakPoint.media.minwidth}px) and (max-width: ${breakPoint.media.maxwidth}px)`; } else {\n      if (breakPoint.media.minwidth) source.media += `(min-width: ${breakPoint.media.minwidth}px)`;\n      if (breakPoint.media.maxwidth) source.media += `(max-width: ${breakPoint.media.maxwidth}px)`;\n    }\n\n    const srcsets = [];\n\n    for (const srcset of breakPoint.srcset) {\n      if (srcset.imgSuffix === 'small') continue;\n      srcsets.push(`${DBHelper.imageUrlForRestaurant(restaurant, srcset.imgSuffix)}  ${srcset.imgCondition}`);\n    }\n\n    // if there is src set Add\n    if (srcsets.length > 0) {\n      source.srcset = srcsets.join(srcsets, ',');\n      // source.dataset.srcset = srcsets.join(srcsets, ',');\n\n      picture.append(source);\n    }\n  }\n\n  const image = document.createElement('img');\n  // image.src = '/img/restaurant.png';\n\n  image.className = 'restaurant-img lazy';\n  image.src = DBHelper.imageUrlForRestaurant(restaurant, 'small');\n  // image.dataset.src = DBHelper.imageUrlForRestaurant(restaurant, 'small');\n\n  image.alt = `Image of the restaurant ${restaurant.name}`;\n  picture.append(image);\n\n  figure.append(picture);\n\n  const figureCaption = document.createElement('figcaption');\n  figureCaption.innerHTML = restaurant.name;\n  figure.append(figureCaption);\n\n\n  li.append(figure); // TODO : append figure\n\n  const name = document.createElement('h2');\n  name.innerHTML = restaurant.name;\n  li.append(name);\n\n  const neighborhood = document.createElement('p');\n  neighborhood.innerHTML = restaurant.neighborhood;\n  li.append(neighborhood);\n\n  const address = document.createElement('p');\n  address.innerHTML = restaurant.address;\n  li.append(address);\n\n  const more = document.createElement('a');\n  more.innerHTML = 'View Details';\n  more.href = DBHelper.urlForRestaurant(restaurant);\n  more.setAttribute('tabindex', index + 3);\n  li.append(more);\n\n  // Set Tabindex\n  return li;\n};\n\n/**\n * Add markers for current restaurants to the map.\n */\nconst addMarkersToMap = (restaurants = self.restaurants) => {\n  restaurants.forEach((restaurant) => {\n    // Add marker to the map\n    const marker = DBHelper.mapMarkerForRestaurant(restaurant, self.map);\n    google.maps.event.addListener(marker, 'click', () => {\n      window.location.href = marker.url;\n    });\n    self.markers.push(marker);\n  });\n};\n","class SWService {\n  registerServiceWorker() {\n    if (!navigator.serviceWorker) return;\n\n    const indexController = this;\n\n    navigator.serviceWorker.register('/sw.js').then((reg) => {\n      if (!navigator.serviceWorker.controller) {\n        return;\n      }\n\n      if (reg.waiting) {\n        indexController.updateReady(reg.waiting);\n        return;\n      }\n\n      if (reg.installing) {\n        indexController.trackInstalling(reg.installing);\n        return;\n      }\n\n      reg.addEventListener('updatefound', () => {\n        indexController.trackInstalling(reg.installing);\n      });\n    });\n\n    // Ensure refresh is only called once.\n    // This works around a bug in \"force update on reload\".\n    let refreshing;\n    navigator.serviceWorker.addEventListener('controllerchange', () => {\n      if (refreshing) return;\n      window.location.reload();\n      refreshing = true;\n    });\n  }\n\n  showCachedMessages() {\n    const indexController = this;\n\n    return this._dbPromise.then((db) => {\n      // if we're already showing posts, eg shift-refresh\n      // or the very first load, there's no point fetching\n      // posts from IDB\n      if (!db || indexController._postsView.showingPosts()) return;\n\n      const index = db.transaction(indexedDBName)\n        .objectStore(indexedDBName).index('by-date');\n\n      return index.getAll().then((messages) => {\n        indexController._postsView.addPosts(messages.reverse());\n      });\n    });\n  }\n\n  trackInstalling(worker) {\n    const indexController = this;\n    worker.addEventListener('statechange', () => {\n      if (worker.state == 'installed') {\n        indexController.updateReady(worker);\n      }\n    });\n  }\n\n\n  updateReady(worker) {\n    worker.postMessage({\n      action: 'skipWaiting',\n    });\n  }\n}\n\n\nconst swregister = new SWService();\nswregister.registerServiceWorker();\n"]}